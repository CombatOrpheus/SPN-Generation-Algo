%% [steady_state, mark_density, mu_values, lambda] = generate_steady_state_info(reachability_graph, num_transitions)
%%
%% Generates random firing rates (lambda) and calculates steady-state properties.
%%
%% This function orchestrates the steady-state analysis of a bounded SPN whose
%% reachability graph has already been computed. It performs the following steps:
%% 1. Generates a random vector of firing rates (lambda) for the transitions.
%% 2. Constructs the state-space equations for the underlying Continuous-Time
%%    Markov Chain (CTMC) using the reachability graph and firing rates.
%% 3. Solves the system of linear equations to find the steady-state probability
%%    distribution for all reachable markings.
%% 4. If a solution is found, it computes derived metrics like marking density
%%    and average token counts (`mu`) using `calculate_average_markings`.
%%
%% Inputs:
%%   reachability_graph: A structure containing the complete reachability graph,
%%                       as generated by `get_reachability_graph`. It must include
%%                       `.v_list`, `.edge_list`, and `.arctrans_list`.
%%
%%   num_transitions: An integer specifying the total number of transitions in the SPN.
%%
%% Outputs:
%%   steady_state: A column vector containing the steady-state probability for
%%                 each marking. Returns empty if the solver fails.
%%
%%   mark_density: The marking density matrix, as computed by
%%                 `calculate_average_markings`. Returns empty if no solution.
%%
%%   mu_values: A vector of the average number of tokens (mu) for each place.
%%              Returns empty if no solution.
%%
%%   lambda: The randomly generated `num_transitions` x 1 vector of firing rates
%%           used in the analysis.

function [steady_state, mark_density, mu_values, lambda] = generate_steady_state_info(reachability_graph, num_transitions)
  % For this analysis, generate random firing rates for each transition.
  lambda = randi(10, num_transitions, 1);

  % Build and solve the state equations for the CTMC.
  [state_matrix, y_list] = state_equation( ...
    reachability_graph.v_list, ...
    reachability_graph.edge_list, ...
    reachability_graph.arctrans_list, ...
    lambda ...
  );

  % Solve for the steady-state vector 'pi' in 'Q * pi = y'.
  try
    % Use the backslash operator (mldivide) for efficient and accurate solving.
    steady_state = state_matrix \ y_list;
  catch
    % If the matrix is singular or ill-conditioned, the solver will fail.
    steady_state = [];
    mark_density = [];
    mu_values = [];
    return;
  end

  % If a steady-state solution was found, calculate derived metrics.
  if ~isempty(steady_state)
    [mark_density, mu_values] = calculate_average_markings(reachability_graph.v_list, steady_state);
  end
endfunction