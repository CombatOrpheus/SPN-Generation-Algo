%% [steady_state, mark_density, mu_values, lambda] = generate_steady_state_info(reachability_graph, num_transitions, solver)
%%
%% Generates random firing rates (lambda) and calculates steady-state properties.
%%
%% This function orchestrates the steady-state analysis of a bounded SPN whose
%% reachability graph has already been computed. It performs the following steps:
%% 1. Generates a random vector of firing rates (lambda) for the transitions.
%% 2. Constructs the sparse state-space equations for the underlying CTMC.
%% 3. Solves the system of linear equations using either a direct solver or a
%%    user-specified iterative solver.
%% 4. If a solution is found, it computes derived metrics like marking density
%%    and average token counts (`mu`).
%%
%% Inputs:
%%   reachability_graph: A structure containing the complete reachability graph,
%%                       as generated by `get_reachability_graph`.
%%
%%   num_transitions: The total number of transitions in the SPN.
%%
%%   solver: (Optional) A string specifying the solver to use.
%%           - 'exact': Uses the standard backslash operator (`\`), a direct method.
%%           - 'iterative': Uses the GMRES iterative solver, suitable for large sparse systems.
%%           Default is 'exact'.
%%
%% Outputs:
%%   steady_state: A column vector containing the steady-state probability for
%%                 each marking. Returns empty if the solver fails.
%%
%%   mark_density: The marking density matrix. Returns empty if no solution.
%%
%%   mu_values: A vector of the average number of tokens (mu) for each place.
%%              Returns empty if no solution.
%%
%%   lambda: The randomly generated firing rates used in the analysis.

function [steady_state, mark_density, mu_values, lambda] = generate_steady_state_info(reachability_graph, num_transitions, solver = 'exact')
  % For this analysis, generate random firing rates for each transition.
  lambda = randi(10, num_transitions, 1);

  % Build the sparse state equations for the CTMC.
  [state_matrix, y_list] = state_equation( ...
    reachability_graph.v_list, ...
    reachability_graph.edge_list, ...
    reachability_graph.arctrans_list, ...
    lambda ...
  );

  % Solve for the steady-state vector 'pi' in 'Q * pi = y'.
  try
    if strcmp(solver, 'exact')
      % Use the backslash operator (mldivide) for efficient and accurate solving.
      steady_state = state_matrix \ y_list;
    else
      % Use the specified iterative solver. GMRES is a good general-purpose
      % choice for non-symmetric sparse systems.
      % The solver function is called directly by its name.
      [steady_state, flag] = feval(solver, state_matrix, y_list, [], 100);
      if flag != 0
        % A non-zero flag indicates the solver did not converge.
        error('Iterative solver (%s) did not converge to a solution.', solver);
      endif
    endif
  catch err
    % If the matrix is singular, ill-conditioned, or the solver fails.
    warning('Solver failed: %s', err.message);
    steady_state = [];
    mark_density = [];
    mu_values = [];
    return;
  end

  % If a steady-state solution was found, calculate derived metrics.
  if ~isempty(steady_state)
    [mark_density, mu_values] = calculate_average_markings(reachability_graph.v_list, steady_state);
  end
endfunction